<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../assets/main.css">
  <title>Doubly Linked Lists</title>
</head>
<body>
  <article>
    <h3>We know what lists are but doubly?</h3>
    <p>
      <strong>Almost</strong> identicla to Singly Linked Lists, except every node has another pointer, to the <strong>previous</strong> node
    </p>
    <h2>
      Comparisons with Singly Linked Lists
    </h2>
    <p>
      More memory === More Flexibility
    </p>
    <p>
      It's <strong>almost</strong> always a tradeoff!
    </p>
  </article>

  <article>
    <h3>
      Pushing
    </h3>
    <p>
      Adding a node to the <strong>end</strong> of the Doubly Linked List
    </p>
    <h3>
      Pushing pseudocode
    </h3>
    <p>
      <ul>
        <li>
          Create a new node with the value passed to the function
        </li>
        <li>
          If the head preoperty is null set the head and tail to be newly created node
        </li>
        <li>
          If not, set the next property on the tail to be that node
        </li>
        <li>
          Set the previous property on the newly created node to be the tail
        </li>
        <li>
          Set the tail to be the newly created node
        </li>
        <li>
          Increment the length
        </li>
      </ul>
    </p>
  </article>

  <article>
    <h3>
      Popping
    </h3>
    <p>
      Removing a node from the <strong>end</strong> of the Double linked list
    </p>
    <h3>
      Popping pseudocode
    </h3>
    <ul>
      <li>
        If there is no head, return undefined
      </li>
      <li>
        Store the current tail in a variable to return later
      </li>
      <li>
        If the length is 1, set the head and tail to be null
      </li>
      <li>
        Update the tail to be the previous Node
      </li>
      <li>
        Set newTail's next to null
      </li>
      <li>
        Decrement the length
      </li>
      <li>
        Return the value removed
      </li>
    </ul>
  </article>

  <article>
    <h3>
      Shift
    </h3>
    <p>
      Removing a node from the <strong>begginning</strong> of the Doubly Linked List
    </p>
    <h3>
      Shift pseudocode
    </h3>
    <ul>
      <li>
        If length is 0, return udefined
      </li>
      <li>
        Store the current head property in a variable (we'll call it old head)
      </li>
      <li>
        If the length is one
        <ul>
          <li>
            Set the head to null
          </li>
          <li>
            Set the tail to null
          </li>
        </ul>
      </li>
      <li>
        Update the head to be the next of the old head
      </li>
      <li>
        Set the head's prev property to null
      </li>
      <li>
        Set the old head's next to null
      </li>
      <li>
        Decrement the length
      </li>
      <li>
        Return the old head
      </li>
    </ul>
  </article>

  <article>
    <h3>
      Unshift
    </h3>
    <p>
      Adding a node to the <strong>beggining</strong> of the Doubly Linked List
    </p>
    <h3>
      Unshift pseudocode
    </h3>
    <ul>
      <li>
        Create a new node with the value passed to the function
      </li>
      <li>
        If the length is 0
        <ul>
          <li>
            Set the head to be the new node
          </li>
          <li>
            Set the tail to be the new node
          </li>
        </ul>
      </li>
      <li>
        Otherwise
        <ul>
          <li>
            Set the prev property on the head of the list to be the new node
          </li>
          <li>
            Set the next property of the new node to be the head property
          </li>
          <li>
            Update th head to be the new node
          </li>
        </ul>
      </li>
      <li>
        Increment the length
      </li>
      <li>
        Return list
      </li>
    </ul>
  </article>

  <article>
    <h3>GET</h3>
    <p>
      Accessing a node in a Doubly Linked List by its position
    </p>
    <h3>
      Get Pseudocode
    </h3>
    <ul>
      <li>
        If index is less than 0 or greater or equal to the length, return null
      </li>
      <li>
        If the index is less than or equal to half the length of the list
          <ul>
            <li>
              Loop through the list starting from the head and loop towards the middle
            </li>
            <li>
              Return the node once it is found
            </li>
          </ul>
      </li>
      <li>
        If the index is greater than half the length of the list
          <ul>
            <li>
              Loop through the list starting from the tail and loop towards the middle
            </li>
            <li>
              Return the node once it is found
            </li>
          </ul>
      </li>
    </ul>
  </article>
  
  <article>
    <h3>
      Set
    </h3>
    <p>
      Replacing the value of a node to the in a Doubly Linked List
    </p>
    <h3>
      Set pseudocode
    </h3>
    <ul>
      <li>
        Create a variable which is the result of the <strong>get</strong> method at the index passed to the function
        <ul>
          <li>
            If the <strong>get</strong> method returns a valid node, set the value of that node to be the value passed to the function
          </li>
          <li>
            Return true
          </li>
        </ul>
      </li>
      <li>
        Otherwise, return false
      </li>
    </ul>
  </article>

  <article>
    <h3>
      Insert
    </h3>
    <p>
      Adding a node in a Doubly Linked List by a certain position
    </p>
    <h3>
      Insert pseudocode
    </h3>
    <ul>
      <li>
        If the index is less than zero or greater than or equal to the length return false
      </li>
      <li>
        If the index is 0, use <strong>unshift</strong>
      </li>
      <li>
        If the index is the same as the length, use <strong>push</strong>
      </li>
      <li>
        Use the <strong>get</strong> method to access the index -1
      </li>
      <li>
        Set the next and prev properties on the correct nodes to lik everything together
      </li>
      <li>
        Increment length
      </li>
      <li>
        Return true
      </li>
    </ul>
  </article>

  <article>
    <h3>
      Remove
    </h3>
    <p>
      Removing a node in a Doubly Linked List by a certain position
    </p>
    <h3>
      Remove pseudocode
    </h3>
    <ul>
      <li>
        If the index is less than zero or greater than or equal to the length return undefined
      </li>
      <li>
        If the index is 0, use <strong>shift</strong>
      </li>
      <li>
        If the index is the same a the length -1, use <strong>pop</strong>
      </li>
      <li>
        Use the <strong>get</strong> method to retrieve the item to be removed
      </li>
      <li>
        Update the next and prev properties to remove the found node from the list
      </li>
      <li>
        Set next and prev to null the found node;
      </li>
      <li>
        Decrement the length
      </li>
      <li>
        Return node
      </li>
    </ul>
  </article>

  <script>
    class Node {
      constructor(val) {
        this.val = val;
        this.next = null;
        this.prev = null;
      }
    };

    class DoublyLinkedList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      };

      push = val => {
        // Create a new node with the value passed to the function
        const newNode = new Node(val);
        // If the head preoperty is null set the head and tail to be newly created node
        if (this.length === 0) {
          this.head = newNode;
          this.tail = newNode;
        // If not, set the next property on the tail to be that node
        } else {
          // Set the previous property on the newly created node to be the tail
          this.tail.next = newNode;
          newNode.prev = this.tail;
          // Set the tail to be the newly created node
          this.tail = newNode;
        }
        // Increment the length
        this.length++;
        return this;
      };

      pop = () => {
        // If there is no head, return undefined
        if (this.length === 0) return undefined;
        // Store the current tail in a variable to return later
        const popedNode = this.tail;
        // If the length is 1, set the head and tail to be null
        if (this.length === 1) {
          this.head = null;
          this.tail = null;
        } else {
          // Update the tail to be the previous Node
          this.tail = popedNode.prev;
          // Set newTail's next to null
          this.tail.next = null;
          popedNode.prev = null;
        }
        // Decrement the length
        this.length--;
        // Return the value removed
        return popedNode;
      };

      shift = () => {
        // If length is 0, return udefined
        if (this.length === 0) return undefined;
        // Store the current head property in a variable (we'll call it old head)
        const oldHead = this.head;
        // If the length is one
        if (this.length === 1) {
          // Set the head to null
          this.head = null;
          // Set the tail to null
          this.tail = null;
        } else {
          // Update the head to be the next of the old head
          this.head = oldHead.next;
          // Set the head's prev property to null
          this.head.prev = null
          // Set the old head's next to null
          oldHead.next = null;
        }
        // Decrement the length
        this.length--;
        // Return the old head
        return oldHead;
      };

      unshift = val => {
        // Create a new node with the value passed to the function
        const newNode = new Node(val);
        // If the length is 0
        if (this.length === 0) {
          // Set the head to be the new node
          this.head = newNode;
          // Set the tail to be the new node
          this.tail = newNode;
        } else {
          // Set the prev property on the head of the list to be the new node
          this.head.prev = newNode;
          // Set the next property of the new node to be the head property
          newNode.next = this.head;
          // Update th head to be the new node
          this.head = newNode
        }
        // Increment the length
        this.length++;
        // Return list
        return this;
      };

      get = index => {
        if (index < 0 || index >= this.length) return null;
        let count, current;
        if (index <= this.length/2) {
          count = 0;
          current = this.head;

          while (count !== index) {
            current = current.next;
            count++
          };

        } else {
          count = this.length - 1;
          current = this.tail;

          while (count !== index) {
            current = current.prev;
            count--;
          };

        };

        return current;
      };

      set = (index, value) => {
        const foundNode = this.get(index);
        if (foundNode !== null) {
          foundNode.val = value;
          return true
        };

        return false;
      };

      insert = (index, value) => {
        // If the index is less than zero or greater than or equal to the length return false
        if (index < 0 || index > this.length) return false;
        // If the index is 0, use unshift
        if (index === 0) !!this.unshift(value);
        // If the index is the same as the length, use push
        if (index === this.length) !!this.push(value);

        // Use the get method to access the index -1
        const beforeNode = this.get(index-1);
        const afterNode = beforeNode.next;
        // Set the next and prev properties on the correct nodes to lik everything together
        const newNode = new Node(value);

        beforeNode.next = newNode; newNode.prev = beforeNode;
        newNode.next = afterNode; afterNode.prev = newNode;
        // Increment length
        this.length++;
        // Return true
        return true;
      };

      remove = index => {
        if (index < 0 || index > this.length) return undefined;
        if (index === 0) return this.shift();
        if (index === this.length - 1) return this.pop();
        const removedNode = this.get(index);
        removedNode.prev.next = removedNode.next;
        removedNode.next.prev = removedNode.prev;
        removedNode.next = null;
        removedNode.prev = null;
        this.length--;
        return removedNode;
      };

      print = () => {
        const arr = [];
        let current = this.head;
        while (current) {
          arr.push(current.val);
          current = current.next;
        };
        console.log(arr);
      };
    };

    const list = new DoublyLinkedList();
    list.push("Harry Potter");        // 0
    list.push("Ron Weasley");         // 1
    list.push("Hermione Granger");    // 2
    list.push("Sirius Black");        // 3
    list.push("Draco Malfoy");        // 4
    list.push("Luna Lovegood");       // 5
    list.push("Neville Longbottom");  // 6

  </script>
</body>
</html>